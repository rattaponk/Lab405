<!DOCTYPE html>
<!-- saved from url=(0025)http://10.80.123.98:8090/ -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Instant Markdown</title>
  <style>
      .markdown-body {
          box-sizing: border-box;
          min-width: 200px;
          max-width: 980px;
          margin: 0 auto;
          padding: 45px;
      }
    </style>
<link rel="stylesheet" href="./Instant Markdown_files/github-markdown.css">
<link rel="stylesheet" href="./Instant Markdown_files/github-highlight.css">
<script src="./Instant Markdown_files/socket.io.js.download"></script>
<script>
      var socket = io();
      socket.on('markdown', function (msg) {
        document.getElementById("markdown").innerHTML = msg;
        var cursor = document.getElementById("instant-markdown-cursor");
        if (cursor) {
          cursor.scrollIntoView();
        }
      });
      socket.on('disconnect', function() {
        window.close();
      })
    </script>
</head>

<body>
  <article id="markdown" class="markdown-body"><h1 id="vuejs-instance">VueJS Instance</h1>
<p>Known properties:</p>
<ul>
<li>el</li>
<li>data</li>
<li>methods</li>
<li>computed</li>
<li>watch</li>
</ul>
<h2 id="multiple-vuejs-instance">Multiple VueJS instance?</h2>
<ul>
<li>using different 'el' to refer to different path in DOM, different widgets</li>
<li>the same business logic should be in the same instance</li>
<li>access properties across instance is possible</li>
</ul>
<pre><code>var vm1 = new Vue( { el: '#app1', ... });

// access vm1's method from within vm2
var vm2 = new Vue( { el: '#app2', ... vm1.onChange();... });

// vanilla code: using 'vm1' to refer to the intance
setTimeout(function() {
  vm1.title = 'Changed by Timer';
  vm1.show();
}, 3000);
</code></pre>
<h2 id="manage-data-and-method">Manage Data and Method</h2>
<p>console.log(vm1)  //printing instance</p>
<ul>
<li>there are getter/setter for all properties passed to the VueJS constructor</li>
<li>properties added later will not be watched, and no getter/setter</li>
</ul>
<h3 id="interesting-vuejs-properties">Interesting Vuejs properties</h3>
<ul>
<li>$el: the DOM used as a placeholder for the Vue instance</li>
<li>$data: object stores data, can be set outside the Vue constructor block</li>
<li>they can be interact with normal javascript</li>
</ul>
<pre><code>var my_data = {
  title: 'The Vuejs Instancec',
  showParagraph: false
}

var vm = new Vue({
  el: '#app',
  data: my_data
});
</code></pre>
<ul>
<li>$ref: a reference to access DOM using Vue, good for getting something but not so much for setting</li>
</ul>
<pre><code>&lt;h1 ref="heading"&gt;{{ title }}&lt;/h1&gt;
&lt;button v-on:clock="show" ref="myButton"&gt;Show&lt;/button&gt;

var vm1 = new Vue( {
  ...
  methods: {
    show: function() {
      console.log(this.$refs);
      this.$refs.myButton.innerText = 'Test';
    }
  }
});

// but the interpolation is not overwritten
// changing in the DOM directly, but not in the template generated by Vue
vm1.$refs.heading.innerText = 'Something else';
</code></pre>
<h3 id="mounting-template">Mounting Template</h3>
<ul>
<li>Vue instance without 'el' can mount to a placeholder dynamically</li>
</ul>
<pre><code>vm1.$mount('#app1');
</code></pre>
<ul>
<li>template: a property for setting HTML template for Vue instance</li>
</ul>
<pre><code>&lt;div id="app3"&gt; &lt;/div&gt;    // empty template in HTML part

var vm3 = new Vue( { 
  template: ''' &lt;h1&gt; Hello! &lt;/h1&gt; '''
});

vm3.$mount('#app3');  // or...

vm3.$mount();         // normal javascript - uncommon
document.getElementById('app3').appendChild(vm3.$el);
</code></pre>
<h3 id="using-component">Using component</h3>
<ul>
<li>if we want to have reusable components</li>
<li>component registration: Vue.component({...});</li>
</ul>
<pre><code>&lt;hello&gt;&lt;/hello&gt;
&lt;hello&gt;&lt;/hello&gt;

Vue.component( 'hello', {
  template: '&lt;h1&gt;Hello!&lt;/h1&gt;' // mount to all 'hello' placeholder

});

var vm3 = new Vue( { 
  el: 'hello',          // mount only to the first 'hello' placeholder
  template: ''' &lt;h1&gt; Hello! &lt;/h1&gt; ''' //string of HTML
});
</code></pre>
<h2 id="vuejs-dom-updating">VueJS DOM Updating</h2>
<ul>
<li>Vue Instance:</li>
<li>Virtual DOM: representation of the real DOM (kind of copy), quick to update</li>
<li>DOM: updated only the part that Virtual DOM different from Vue instance</li>
</ul>
<h2 id="vuejs-instance-lifecycle">VueJS Instance Lifecycle</h2>
<p>new Vue() -&gt; <strong>beforeCreate()</strong> -&gt; initialize Data &amp; Events -&gt; Instance Created ( <strong>created()</strong> ) -&gt;</p>
<p>compile template or **'el'**s template -&gt; <strong>beforeMount()</strong> -&gt; replace <strong>'el'</strong> with compiled template -&gt;</p>
<p>mounted to DOM -&gt; Data Changed -&gt; <strong>beforeUpdate()</strong> -&gt; re-render DOM -&gt; <strong>updated()</strong> -&gt; mounted to DOM</p>
<ul>
<li>Testing licycle hook functions</li>
</ul>
<pre><code>&lt;div id="app"&gt;
  &lt;h1&gt; {{ title }} &lt;/h1&gt;
  &lt;button @click="title = 'Changed'"&gt;Update Title&lt;/button&gt;
  &lt;button @click="destroy"&gt;Destroy&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<pre><code>new Vue( { 
  el: '#app',
  data: {
    title: 'The VueJS Instance'
  },
  beforeCreate: function() {
    console.log('beforeCreate()');
  },
  created: function() {
    console.log('created()');
  },
  beforeMount: function() {
    console.log('beforeMount()');
  },
  mounted: function() {
    console.log('mounted()');
  },
  beforeUpdate: function() {
    console.log('beforeUpdate()');    //will not be called when click 'update' button again
  },
  updated: function() {
    console.log('updated()');         //will not be called when click 'update' button again
  },
  beforeDestroy: function() {
    console.log('beforeDestroy()');
  },
  destroyed: function() {
    console.log('destroyed()');
  },
  methods: {
    destroy: function() {
      this.$destroy();      // destroy this Vue: calling beforeDestroy() and destroyed()
    }
  }
} );
</code></pre>
</article>


</body></html>